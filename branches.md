# Ветвление

Возможность ветвления доступна в большинстве современных систем контроля версий. Однако эта операция в ряде систем может быть довольно затратной как по времени, так и по объему дискового пространства. В Git ветки — это элемент повседневного процесса разработки. По сути ветки в Git представляют собой указатель на снимок изменений. Если нужно добавить новую возможность или исправить ошибку (незначительную или серьезную), вы создаете новую ветку, в которой будут размещаться эти изменения. Объединить нестабильный код с основной базой кода становится сложнее.

## Команда **git branch** — создание, перечисление и удаление веток

Команда **git branch** позволяет создавать, просматривать, переименовывать и удалять ветки. Она не дает возможности переключаться между ветками или выполнять слияние разветвленной истории. Именно поэтому команда **git branch** тесно связана с командами **git checkout** и **git merge**.

Основная команда (без параметров)просто перечисляет существующие ветки, отметив активную (Это синоним команды `git branch --list`):

```
git branch
```

![Пример команды git branch](https://www.techiedelight.com/wp-content/uploads/git-branch-grep.png)


***Некоторые параметры git branch***

1. Создание новой ветки с именем `＜ветка＞`. Эта команда не выполняет переключение на эту новую ветку.

    ```
    git branch <branch>
    ```

2. Удаление указанной ветки. Это «безопасная» операция, поскольку Git не позволит удалить ветку, если в ней есть неслитые изменения.

    ```
    git branch -d <branch>
    ```

3. Принудительное удаление указанной ветки, даже если в ней есть неслитые изменения. Эта команда используется, если вы хотите навсегда удалить все коммиты, связанные с определенным направлением разработки.

     ```
    git branch -D <branch>
    ```



## Команда **git checkout** — переключение между ветками, извлечение файлов

В Git под термином **checkout** подразумевают переключение между различными версиями целевого объекта. Команда *git checkout* работает с тремя различными объектами:

* файлами 
* коммитами 
* ветками. 

Под переключением также обычно понимают действие, связанное с выполнением команды git checkout.

Переключение веток аналогично переключению старых коммитов и файлов, в которых рабочий каталог обновляется в соответствии с выбранной веткой/ревизией; вместе с тем новые изменения сохраняются в истории проекта, то есть это не просто операция чтения.

Команда **git checkout** позволяет перемещаться между ветками, созданными командой **git branch**. При переключении ветки происходит обновление файлов в рабочем каталоге в соответствии с версией, хранящейся в этой ветке, а Git начинает записывать все новые коммиты в этой ветке. Рассматривайте эту команду как способ выбрать направление своей разработки.

1. Если предположить, что ваш рабочий репозиторий уже содержит существующие ветки, вы можете переключаться между этими ветками с помощью команды git checkout. Чтобы узнать, какие ветки доступны и как называется текущая ветка, выполните команду git branch.

    ```
    $＞ git branch 
    main 
    another_branch 
    feature_inprogress_branch 
    $＞ git checkout feature_inprogress_branch
    ```

В вышеприведенном примере показано, как просмотреть список доступных веток с помощью команды **git branch** и переключиться на конкретную ветку (в данном случае — на ветку `feature_inprogress_branch`).


2. Когда вы захотите начать работу над новой функцией, создайте новое ответвление от ветки main с помощью команды `git branch new_branch`. Затем переключитесь на новую ветку с помощью команды `git checkout new_branch`. Команда **git checkout** также принимает аргумент `-b`, который действует как вспомогательный метод, позволяя создать новую ветку и сразу переключиться на нее. Вы можете работать сразу с несколькими функциями в одном репозитории, переключаясь между ними с помощью **git checkout**.

    ```
    git checkout -b ＜new-branch＞
    ```
В вышеприведенном примере одновременно создается ветка `<новая-ветка>` и сразу же выполняется переключение на нее. Опция `-b` — это удобный способ сообщить системе Git, чтобы она выполнила команду `git branch <новая-ветка>` перед выполнением команды `git checkout <новая-ветка>`.



## Команда **git merge** — слияние веток

Слияние используется в Git, чтобы собрать воедино разветвленную историю. Команда **git merge** выполняет слияние отдельных направлений разработки, созданных с помощью команды **git branch**, в единую ветку.

> Обратите внимание: все приведенные ниже команды выполняют слияние в текущую ветку, в то время как целевая ветка остается без изменений. Поэтому команда **git merge** часто используется в сочетании с командами **git checkout** (для выбора текущей ветки) и `git branch -d` (для удаления устаревшей целевой ветки).

Перед слиянием следует предпринять несколько подготовительных действий, чтобы операция прошла без проблем:

* Выполните команду **git status**. Это позволит убедиться, что *HEAD* указывает на ветку, принимающую результаты слияния. При необходимости выполните команду `git checkout <принимающая-ветка>`, чтобы переключиться на принимающую ветку.
  
* Убедитесь, что в принимающей ветке и ветке для слияния содержатся последние изменения из удаленного репозитория. Выполните команду **git fetch**, чтобы получить из него последние коммиты.

* Затем убедитесь, что в ветке **main** также содержатся последние изменения. Для этого выполните команду **git pull**.
  
* После указанных выше действий по подготовке можете приступать к слиянию. Для этого выполните команду `git merge <название ветки>`, где `<название ветки>` — название ветки, которая будет объединена с принимающей.


## Команда **git rebase** 

**Перебазирование** — это один из двух инструментов Git для внедрения изменений из одной ветки в другую. Такие же возможности предоставляет команда **git merge (слияние)**. Операция слияния фиксирует изменения, всегда двигаясь вперед по истории проекта, в то время как перебазирование позволяет эффективно ее переписывать. Перебазирование может выполняться в двух режимах: 
* ручном 
* интерактивном.

Перебазирование — это процесс перемещения последовательности коммитов к новому базовому коммиту или их объединение. Операцию перебазирования удобнее всего применить и отобразить в контексте создания функциональных веток. В общих чертах процесс можно представить следующим образом:


![пример перебазирования](https://wac-cdn.atlassian.com/dam/jcr:4e576671-1b7f-43db-afb5-cf8db8df8e4a/01%20What%20is%20git%20rebase.svg?cdnVersion=408)

С точки зрения содержимого **перебазирование** — это замена одного коммита в основании ветки на другой, в результате чего создается впечатление, что ветка получила новое начало. В процессе этой операции Git создает новые коммиты и применяет их к указанному основанию, поэтому важно понимать, что в действительности ветка всегда состоит из совершенно новых коммитов.

> Ни при каких обстоятельствах не следует выполнять перебазирование коммитов, отправленных в публичный репозиторий. Команда **rebase** заменит старые коммиты на новые, и другим разработчикам покажется, будто часть истории проекта просто исчезла.


Чтобы выполнить перебазирование в интерактивном режиме, к команде** git rebase** нужно добавить аргумент `-i` (от interactive — «интерактивный»). При выполнении команды без аргументов она запустится в стандартном режиме.


1. **Стандартный режим**
   
    В стандартном режиме команда git rebase автоматически берет коммиты из текущей рабочей ветки и применяет их в конце переданной ветки.
    ```
    git rebase <base>
    ```
    Текущая ветка автоматически перебазируется на основание . Для этого можно использовать любую ссылку на коммит (например, идентификатор, название ветки, тег или относительную ссылку на HEAD).

2. **Интерактивный режим**

    Если запустить команду **git rebase** с флагом `-i`, перебазирование будет выполняться в интерактивном режиме. Этот режим исключит необходимость перемещения коммитов вслепую на новое основание и позволит изменять отдельные коммиты при выполнении операции. Так вы можете очистить историю путем удаления, разделения и изменения коммитов в существующей последовательности. Получится что-то вроде команды `git commit --amend` на стероидах!

    ```
    git rebase --interactive <base>
    ```

Текущая ветка будет перенесена на основание  в интерактивном режиме. Откроется редактор, где вы сможете вводить команды (описаны ниже) для каждого перебазируемого коммита. С помощью этих команд можно определить способ переноса отдельных коммитов на новое основание, а также переупорядочить список коммитов, чтобы изменить их будущий порядок. Когда команды будут указаны для каждого актуального коммита, Git начнет их применение.

*Дополнительные команды перебазирования:*

* `git rebase -d` — во время операции коммит будет исключен из окончательного блока объединенных коммитов.
  
* `git rebase -p` — коммит останется в исходном виде. Операция не затронет сообщение и содержимое коммита. При этом сам коммит сохранится в истории веток отдельно.
  
* `git rebase -x` — для каждого отмеченного коммита будет выполнен скрипт командной строки. Эта опция может быть полезной при тестировании базы кода на отдельных коммитах, поскольку с ее помощью можно выявить ошибки в ходе перебазирования.


Команде **git rebase** можно передать аргумент командной строки `--onto`. При использовании аргумента `--onto` команда **git rebase** примет следующий вид:

```
git rebase --onto <newbase> <oldbase>
```

>Опция `--onto` расширяет возможности перебазирования. Теперь команде **rebase** можно передавать конкретные ссылки в качестве оснований для перебазирования.


***Опасности перебазирования***

1. Одна из них заключается в конфликтах слияния, которые проявляются чаще, если ветка существует достаточно долго и имеет значительные отличия от главной. 

К тому времени, когда вы захотите перебазировать такую ветку на главную, в последней может возникнуть множество новых коммитов, которые будут конфликтовать с изменениями вашей ветки. Чтобы избежать этого, необходимо регулярно выполнять перебазирование ветки на главную и чаще делать коммиты.


2. При перезаписи истории в интерактивном режиме некоторые коммиты могут быть утрачены.

Выполнение перебазирования в интерактивном режиме вместе с такими подкомандами, как squash или drop, приведет к удалению коммитов из локальной истории вашей ветки. Сначала покажется, что коммиты удалены навсегда, но их можно восстановить с помощью команды git reflog. При этом операция перебазирования будет полностью отменена.

> Сама по себе команда git rebase не сопряжена с серьезной опасностью. Риск возникает, если вы используете интерактивное перебазирование для перезаписи истории и затем принудительно отправляете результаты в удаленную ветку, где работают другие пользователи. Этого делать не стоит, поскольку работа удаленных пользователей может быть перезаписана при осуществлении pull.


# Краткие итоги

 
* Рассмотрели основные команды при работе с ветками

* Сравнили стандартный и интерактивный режимы команды **git rebase**
  
* Узнали о расширенной опции `git rebase --onto`
  
* Выделили опасности, встречающиеся при перебазировании
























