# Архитектура двух деревьев 

Система контроля версий git имеет архитектуру трех деревьев. Перед тем как перейти к ее описанию, для начала, рассмотрим архитектуру двух деревьев. Схематично она выглядит так, как представлено на рисунке ниже:


<br>

![Архитектура двух деревьев](https://devpractice.ru/wp-content/uploads/2018/02/git-for-beginners-part4-pic1.png, "Архитектура двух деревьев")

<br>

Для начала введем используемую терминологию:

* **Рабочая копия** (working copy) - набор файлов, с которым мы работаем в данный момент.
  
* **Коммит** (Commit) - в нем содержится описание тех изменений, которые вносит пользователь в код приложения. Коммиты можно рассматривать как снимки состояния или контрольные точки на временной шкале проекта. Грубо говоря, каждый коммит это снимок состояния проекта на текущий момент времени. В роли существительного: «моментальный снимок» рабочего дерева в какой-то момент времени. В роли глагола: коммитить (закоммитить) — добавлять коммит в репозиторий.


* **Рабочее дерево** (Working tree) — Любая директория в вашей файловой системе, связанная с репозиторием (что можно видеть по наличию в ней поддиректории «.git»). Включает в себя все файлы и поддиректории.

* **Репозиторий** (Repository) — это место, где хранится ваш код и вся информация о его изменениях. Репозитории могут находиться у вас на компьютере, на компьютерах ваших коллег и на удалённом сервере.

* **Индекс** (также называют "кэш" или "область подготовки" (stage) ). В отличие от других подобных инструментов, Git не передает изменения из рабочего дерева в репозиторий напрямую. Вместо этого изменения сначала регистрируются в индексе, или "области подготовки" (stage). Это можно рассматривать как способ "подтверждения" ваших изменений перед совершением коммита, который запишет в репозиторий все одобренные изменения.
  
<br>  

Итак, есть <u>репозиторий</u> и <u>рабочая копия</u>. Это два дерева. Мы называем их деревьями, потому что они представляют структуру файлов/папок. Главный каталог проекта находится вверху, а под ним могут быть 4 или 5 разных папок с несколькими файлами внутри. Может быть, еще несколько папок, в каждой из этих папок есть еще несколько папок внутри. Вы можете себе представить, что если вы нанесете это на карту, каждая из этих папок будет разветвляться, как ветви дерева.

Представим, что у нас есть несколько файлов. Было решено, что мы внесли в них все необходимые изменения. Следующим шагом нужно сообщить об этом  системе контроля версий. Для этого разработчик производит отправку изменений в ***репозиторий (repository)***. Сама операция отправки изменений называется ***commit***, на русском языке ее так и называют – ***коммит***. Если нам необходимо взять данные из репозитория (операция, обратная коммиту), то мы осуществляем операцию ***checkout*** (на русском языке ее так же и называют – ***чекаут***.). Для чего это нужно? 
Можем представить себе такую ситуацию. Есть некий репозиторий и он является общим, т.е. другие разработчики тоже работают с ним и они могут добавлять в репозиторий свои собственные изменения. Если мы не извлечем копию из репозитория с изменениями, внесенными другими разработчиками, то наша рабочая копия не будет иметь этих изменений и будет отличаться от той, что находится в репозитории. Это может привести к различным ошибкам.

<br>

# Архитектура трех деревьев

Система контроля версий git использует архитектуру трех деревьев. Схематично она выглядит так как показано на рисунке ниже:

<br>

![Архитектура трех деревьев](https://devpractice.ru/wp-content/uploads/2018/02/git-for-beginners-part4-pic2.png, "Архитектура трех деревьев")

<br>

По сути она почти ничем не отличается от архитектуры двух деревьев, разница заключается в том, что дополнительно добавляется ещё одно место, которое можно назвать ***кэш, stage*** или ***индекс***. 

Наличие "кэша" добавляет гибкости в процесс разработки, например, вы можете внести изменения в довольно большое количество файлов, но отправить их в репозиторий в разных коммитах со своими специфическими комментариями и т.п.

<br>

# Хранение данных

Наиболее часто используемыми архитектурными решениями для хранения данных в мире систем контроля версий являются:

**1. VCS - набор изменений на основе дельты**.

Они инкапсулируют отличия между двумя версиями сведенных данных, дополняя их некоторым количеством метаданных. 

<br>

**2. Представление данных в форме ациклического ориентированного графа (DAG)**

Представление данных в форме ациклического ориентированного графа подразумевает использование объектов, формирующих иерархию, которая отражает  содержимое дерева файловой системы контента как снимок фиксации (при этом не изменяющиеся объекты в рамках дерева используются повторно тогда, когда это возможно). 


**Примечание**: Git хранит данные в виде ациклического ориентированного графа, использующего различные типы объектов.

<br>

Git — это файловая система с адресацией по содержимому, состоящая из объектов, образующих иерархию, отражающую дерево файловой системы содержимого. 

В Git используются 4 основных типа примитивных объектов для каждого из типов данных, на основе которых строится локальный репозиторий. 

*Примитивные типы объектов*:

- Дерево (Tree): элемент дерева может являться данными или еще одним деревом в случае представления директории с данными.
  
- Данные (Blob): данный тип объекта используется для представления файла, находящегося в репозитории

- Измененные данные (Commit): данный тип объекта используется для указания на дерево, представляющее директорию верхнего уровня для измененных в ходе текущей операции данных, а также для ранее измененных данных и стандартных атрибутов.
  
- Тэг (Tag): тэг имеет имя и указывает на операцию изменения данных в истории изменений репозитория, которую он представляет.


Объект каждого типа имеет следующие атрибуты:
- тип (type) 
- размер (size)
- данные (content). 


Для ссылок на все примитивные объекты используются SHA-хэши, являющиеся идентификаторами объектов из 40 цифр, которые имеют следующие свойства:

* В том случае, если два объекта являются идентичными, они будут иметь одинаковые SHA-хэши.
 
* В том случае, если объекты различаются, они будут иметь разные SHA-хэши.
  
* В том случае, если объект был только частично скопирован или произошло другое повреждение данных, повторный расчет SHA-хэша для данного объекта поможет обнаружить такое повреждение данных.
  
Два первых свойства SHA-хэшей, относящиеся к установлению идентичности объектов, полезны для реализации распределенной модели Git. Последнее свойство позволяет организовать систему защиты от повреждения данных.

Git также использует DAG для отслеживания истории изменений содержимого. Каждый объект фиксации содержит метаданные о своих предках, где фиксация может иметь любое количество родительских коммитов. Использование Git DAG для хранения контента и отслеживания истории коммитов и слияний позволяет ему поддерживать полную возможность ветвления, поскольку история файла связана на всем пути до его структуры каталогов с корневым каталогом и объектом коммита.

<br>

![Алгоритм хэширования SH1](https://miro.medium.com/max/1400/1*RjWycLnGR_WxzMTXRSLSCA.png)

<div class= "header" text align = "center">Рис. 1 Пример алгоритма хэширования SHА </div>

<br>

Несмотря на желаемые результаты использования хранилища на основе направленных ациклических графов для хранения данных и истории объединений ветвей, для многих репозиториев хранилище на основе данных отличий файлов окажется более эффективным в плане использования дискового пространства, нежели хранилище на основе отдельных объектов, представленных направленными ациклическими графами.

Git решает проблему чрезмерного потребления дискового пространства путем сжатия объектов, причем файл индексирования данных используется для указания на сдвиги, по которым находятся определенные объекты в соответствующем упакованном файле.

---
<div class = "buttonnavigation" align="center">
<p>

[К содержанию](readme.md/#содержание)

[Назад](about_GIT.md) 
[Далее](local_repository.md)

</p>
</div>
